#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2154,SC2312

# Store output artifacts in a versioned directory.
OUTPUT_DIR="${OUTPUT_DIR}/${VERSION_ID}-${BUILD_ID}"

FILENAME_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}-${VERSION_ID}-${BUILD_ID}"
SYMLINK_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}"
VERSIONED_SYMLINK_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}-${VERSION_ID}"
FRIENDLY_VERSIONED_SYMLINK_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}-v${VERSION_ID}"

OS_IMAGE_NAME="${FILENAME_PREFIX}"
OS_IMAGE_SYMLINK="${SYMLINK_PREFIX}"
OS_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}"
OS_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}"

DATA_IMAGE_NAME="${FILENAME_PREFIX}-data"
DATA_IMAGE_SYMLINK="${SYMLINK_PREFIX}-data"
DATA_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-data"
DATA_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-data"

BOOT_IMAGE_NAME="${FILENAME_PREFIX}-boot.ext4.lz4"
BOOT_IMAGE_SYMLINK="${SYMLINK_PREFIX}-boot.ext4.lz4"
BOOT_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-boot.ext4.lz4"
BOOT_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-boot.ext4.lz4"

VERITY_IMAGE_NAME="${FILENAME_PREFIX}-root.verity.lz4"
VERITY_IMAGE_SYMLINK="${SYMLINK_PREFIX}-root.verity.lz4"
VERITY_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-root.verity.lz4"
VERITY_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-root.verity.lz4"

ROOT_IMAGE_NAME="${FILENAME_PREFIX}-root.ext4.lz4"
ROOT_IMAGE_SYMLINK="${SYMLINK_PREFIX}-root.ext4.lz4"
ROOT_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-root.ext4.lz4"
ROOT_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-root.ext4.lz4"

CROSS_FACTORYDIR="/usr/share/factory"
CROSS_SYSCONFIGDIR="/etc"
CROSS_TMPFILESDIR="/usr/lib/tmpfiles.d"

CA_CERTS_BUNDLE="${HOME}/certs/ca-bundle.crt"
CA_CERTS_DEFAULT_BUNDLE="/usr/share/bottlerocket/ca-certificates/ca-bundle.crt"
CA_CERTS_DEFAULT_LICENSES="/usr/share/licenses/ca-certificates"
CA_CERTS_INSTALLDIR="${CROSS_FACTORYDIR}${CROSS_SYSCONFIGDIR}/pki/tls/certs"

SBKEYS="${HOME}/sbkeys"

VERITY_VERSION=1
VERITY_HASH_ALGORITHM=sha256
VERITY_DATA_BLOCK_SIZE=4096
VERITY_HASH_BLOCK_SIZE=4096

install_ca_certs() {
  install -d "${ROOT_MOUNT}${CA_CERTS_INSTALLDIR}"
  if [ -s "${CA_CERTS_BUNDLE}" ]; then
    install -p -m 0644 \
      "${CA_CERTS_BUNDLE}" \
      "${ROOT_MOUNT}${CA_CERTS_INSTALLDIR}"
  elif [ -s "${CA_CERTS_DEFAULT_BUNDLE}" ]; then
    install -p -m 0644 \
      "${CA_CERTS_DEFAULT_BUNDLE}" \
      "${ROOT_MOUNT}${CA_CERTS_INSTALLDIR}"
    install -p -m 0644 \
      -D "${CA_CERTS_DEFAULT_LICENSES}"/* \
      -t "${ROOT_MOUNT}/usr/share/licenses/ca-certificates"
  else
    echo "no CA certificates found" >&2
    exit 1
  fi
  mkdir -p "${ROOT_MOUNT}${CROSS_TMPFILESDIR}"
  cat <<EOF >>"${ROOT_MOUNT}${CROSS_TMPFILESDIR}/ca-certificates.conf"
C /etc/pki/tls/certs/ca-bundle.crt - - - -
L /etc/ssl/certs - - - - ../pki/tls/certs
EOF
}

# shim expects the following data structure in `.vendor_cert`:
#
# struct {
#   uint32_t vendor_authorized_size;
#   uint32_t vendor_deauthorized_size;
#   uint32_t vendor_authorized_offset;
#   uint32_t vendor_deauthorized_offset;
# } cert_table;
#
cert_table() {
  local input output size offset uint32_t
  input="${1:?}"
  output="${2:?}"
  size="$(stat -c %s "${input}")"
  rm -f "${output}"
  # The cert payload is offset by four 4-byte uint32_t values in the header.
  offset="$((4 * 4))"
  for n in "${size}" 0 "${offset}" "$((size + offset))"; do
    printf -v uint32_t '\\x%02x\\x%02x\\x%02x\\x%02x' \
      $((n & 255)) $((n >> 8 & 255)) $((n >> 16 & 255)) $((n >> 24 & 255))
    # shellcheck disable=SC2059  # Variable contains a pattern
    printf "${uint32_t}" >>"${output}"
  done
  cat "${input}" >>"${output}"
  # Zero-pad the output to the expected section size. Otherwise a subsequent
  # `objcopy` operation on the same section might fail to replace it, if the
  # new vendor certificate is larger than this one.
  truncate -s 4096 "${output}"
}

# Helper function to log the object layout before and after changes.
objdumpcopy() {
  local obj objdump objcopy
  obj="${1:?}"
  shift
  objdump="${ARCH}-bottlerocket-linux-gnu-objdump"
  objcopy="${ARCH}-bottlerocket-linux-gnu-objcopy"
  "${objdump}" -h "${obj}"
  "${objcopy}" "${@}" "${obj}"
  "${objdump}" -h "${obj}"
}

sbsetup() {
  local pedb sb_key_source

  # For an AWS profile, we expect a config file for the PKCS11
  # helper. Otherwise, there should be a local key and cert.
  if [ -s "${HOME}/.config/aws-kms-pkcs11/config.json" ]; then
    # Set AWS environment variables from build secrets, if present.
    for var in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN; do
      val="${var,,}"
      val="${HOME}/.aws/${val//_/-}.env"
      [ -s "${val}" ] || continue
      declare -x "${var}=$(cat "${val}")"
    done
    # Verify that AWS credentials are functional.
    aws sts get-caller-identity
    # Log all PKCS11 helper activity, to simplify debugging.
    export AWS_KMS_PKCS11_DEBUG=1
    sb_key_source="aws"
    SHIM_SIGN_KEY=(-c shim-sign-key -t shim-sign-key)
    CODE_SIGN_KEY=(-c code-sign-key -t code-sign-key)
  else
    # Disable the PKCS11 helper.
    rm /etc/pkcs11/modules/aws-kms-pkcs11.module

    # Generate the PKCS12 archives for import.
    openssl pkcs12 \
      -export \
      -passout pass: \
      -inkey "${SBKEYS}/shim-sign.key" \
      -in "${SBKEYS}/shim-sign.crt" \
      -certfile "${SBKEYS}/db.crt" \
      -out "${SBKEYS}/shim-sign.p12"

    openssl pkcs12 \
      -export \
      -passout pass: \
      -inkey "${SBKEYS}/code-sign.key" \
      -in "${SBKEYS}/code-sign.crt" \
      -certfile "${SBKEYS}/vendor.crt" \
      -out "${SBKEYS}/code-sign.p12"

    # Import certificates and private key archive.
    pedb="/etc/pki/pesign"

    certutil -d "${pedb}" -A -n db -i "${SBKEYS}/db.crt" -t ",,C"
    certutil -d "${pedb}" -A -n shim-sign-key -i "${SBKEYS}/shim-sign.crt" -t ",,P"
    pk12util -d "${pedb}" -i "${SBKEYS}/shim-sign.p12" -W ""

    certutil -d "${pedb}" -A -n vendor -i "${SBKEYS}/vendor.crt" -t ",,C"
    certutil -d "${pedb}" -A -n code-sign-key -i "${SBKEYS}/code-sign.crt" -t ",,P"
    pk12util -d "${pedb}" -i "${SBKEYS}/code-sign.p12" -W ""

    certutil -d "${pedb}" -L
    sb_key_source="local"
    SHIM_SIGN_KEY=(-c shim-sign-key)
    CODE_SIGN_KEY=(-c code-sign-key)
  fi

  # Convert certificates from PEM format (ASCII) to DER (binary). This could be
  # done when the certificates are created, but the resulting binary files are
  # not as nice to store in source control.
  for cert in PK KEK db vendor; do
    openssl x509 \
      -inform PEM -in "${SBKEYS}/${cert}.crt" \
      -outform DER -out "${SBKEYS}/${cert}.cer"
  done

  # For signing the grub config, we need to embed the GPG public key in binary
  # form, which is similarly awkward to store in source control.
  gpg --batch --no-tty --import "${SBKEYS}/config-sign.key"
  if [ "${sb_key_source}" == "aws" ]; then
    gpg --batch --no-tty --card-status
  fi
  gpg --batch --no-tty --export >"${SBKEYS}/config-sign.pubkey"
  gpg --batch --no-tty --list-keys
}

veritysetup_format() {
  local root_image="${1:?}"
  local verity_image="${2:?}"

  veritysetup format \
    --format "${VERITY_VERSION}" \
    --hash "${VERITY_HASH_ALGORITHM}" \
    --data-block-size "${VERITY_DATA_BLOCK_SIZE}" \
    --hash-block-size "${VERITY_HASH_BLOCK_SIZE}" \
    "${root_image}" "${verity_image}" |
    tee /dev/stderr
}

symlink_image() {
  local ext what
  ext="${1}"
  what="${2}"
  ext="${ext:+.$ext}"
  target="${what^^}_NAME"
  for link in symlink versioned_symlink friendly_versioned_symlink ; do
    link="${what^^}_${link^^}"
    ln -sf "${!target}${ext}" "${OUTPUT_DIR}/${!link}${ext}"
  done
}
